import logging
import traceback

from django.core.exceptions import ValidationError as DjangoValidationError
from django.utils.translation import gettext_lazy as _

from rest_framework import exceptions, serializers, status
from rest_framework.exceptions import \
    ValidationError as RestFrameworkValidationError
from rest_framework.response import Response
from rest_framework.views import exception_handler

logger = logging.getLogger(__name__)


def custom_exception_handler(exc, context):
    # Call REST framework's default exception handler first,
    # to get the standard error response.
    response = exception_handler(exc, context)

    handlers = {
        "ValidationError": _handle_validation_error,
        "AuthenticationFailed": _handle_rest_framework_exception,
        "NotAuthenticated": _handle_rest_framework_exception,
        "PermissionDenied": _handle_rest_framework_exception
    }

    # Let's identify the type of the current exception to check if we should handle it
    exception_class = exc.__class__.__name__

    # This is the error given, if all things go wrong
    response_data_default = {"errors": _("Could not process this request because of an internal error")}

    # Some errors do not give a Response. We need to handle this case as well
    if response is None:
        response = Response(
            data=response_data_default, content_type="application/json", status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

    # If this exception is one that we can handle, handle it.
    if exception_class in handlers:
        try:
            return handlers[exception_class](exc, context, response)
        except Exception:
            pass

    return _handle_generic_error(exc, context, response)


def _handle_generic_error(exc, context, response):
    """
        The generic error handling is used both as a fallback and for all other handlers.
        We take the response generated by DRF and wrap it in the `errors` key.
    """
    traceback.print_exc()

    if "errors" not in response.data:
        response.data = {"errors": response.data}

    response.data.update({"status_code": response.status_code})
    headers = {}

    if isinstance(exc, exceptions.APIException):
        headers = {}
        if getattr(exc, 'auth_header', None):
            headers['WWW-Authenticate'] = exc.auth_header
        if getattr(exc, 'wait', None):
            headers['Retry-After'] = '%d' % exc.wait

    return Response(response.data, status=response.status_code, headers=headers)


def _handle_validation_error(exc, context, response):
    response.status_code = status.HTTP_400_BAD_REQUEST
    if hasattr(response, "data"):
        response.data = {"errors": response.data}

    if isinstance(exc, DjangoValidationError):
        if "__all__" in dict(exc):
            response.data = {"errors": dict(exc)['__all__']}
        else:
            response.data = {"errors": dict(exc)}

    if isinstance(exc, RestFrameworkValidationError):
        error_dict = serializers.as_serializer_error(exc)
        if "error" in error_dict:
            response.data = {"errors": error_dict.pop("error")}

    return _handle_generic_error(exc, context, response)


def _handle_rest_framework_exception(exc, context, response):
    if hasattr(response, "data"):
        response.data = {"errors": {"message": response.data['detail']}}
    else:
        response.data = {"errors": {"message": str(exc)}}
    return _handle_generic_error(exc, context, response)
